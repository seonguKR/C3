%include "io64.inc"

section .text
global main
main:
    mov rbp, rsp; for correct debugging
    ; 지금까지는 레지스터 공간 8byte 0x16자리(2자리 당 1byte) 4개 a,b,c,d에 값을 16진수로 집어넣는 걸 연습했다.
    ; 하지만 레지스터 말고도 데이터를 저장할 수 있는 공간이 또 있다. 바로 메모리이다. 레지스터와 메모리 간 데이터 핑퐁 방법에 대해 알아보자.
    
    mov rax, 0x123
    mov rbx, 0x12345
    mov rax, a ; 0x403010. a의 주소값(64bit 주소 체계에서 주소값은 무조건 8byte. 여기서 메모리 연산 즉, 1씩 더해보면 옆 이웃 값이 보임 (0x403011~ 0x40301F)
    ; 16진수에서 2를 더하면 0x2, 16을 더하면 0x10, 15를 더하면 0xF (더하기는 최하위 byte부터 진행)
    mov rax, [a]
    ; exe 파일의 data section에 데이터를 잡고 실질적으로 파일을 빌드(compile)후 exe파일을 만들어 실행 -> 빌드 과정에서 잡은 데이터들이 메모리에 올라간다.
    ; 메모리에 올라간 모든 정보는 해당 메모리에 주소가 존재한다(64bit 주소 체계에서 8byte의 주소값을 무조건 가짐)
    ; ** a 자체 크기는 1byte여도 a의 주소값은 8byte로 크기가 개념이 아예 다르다.
    ; 
    
    
; 초기화된 데이터
; db, dw, dd, dq
section .data

 a db 0x11
 b dw 0x2222
 c dd 0x333333
 d dq 0x444444444444


; 초기화되지 않은 데이터 : exe 실행 시 0으로 세팅하기 때문에 크기만 지정해주면 됨
; rsvb, rsvw, rsvd, rsvq
; bss는 왜 data와 공간이 나뉘어져 있을까? -> 파일 크기를 최적화 하기 위해서 -> 메모리 공간을 어떻게 최적화? -> bss는 값을 지정할 수 없고 크기만 지정. 0으로 세팅하기에 값을 지정해줄 필요가 없음 -> exe 파일에 굳이 공간을 내어주지 않아도 됨 -> 메모리에 올라갔을 때 생김
section .bss ; 값은 초기화되지 않은 데이터로 exe파일 내에서 실행되어 실질적으로 메모리에 올라갈 때 0으로 올라감. 우리는 크기만 지정해주면 됨
 
   e resb 10
